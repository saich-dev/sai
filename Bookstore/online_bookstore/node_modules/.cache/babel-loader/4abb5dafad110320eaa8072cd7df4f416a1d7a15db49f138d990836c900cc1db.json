{"ast":null,"code":"import * as React from 'react';\nimport { Action, UNSAFE_invariant, isRouteErrorResponse, createStaticHandler as createStaticHandler$1, UNSAFE_convertRoutesToDataRoutes, IDLE_NAVIGATION, IDLE_FETCHER, IDLE_BLOCKER } from '@remix-run/router';\nimport { UNSAFE_useRoutesImpl, UNSAFE_mapRouteProperties } from 'react-router';\nimport { parsePath, Router, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_FetchersContext, UNSAFE_ViewTransitionContext, createPath } from 'react-router-dom';\n\n/**\n * A `<Router>` that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\",\n  future\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = Action.Pop;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state != null ? locationProp.state : null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: location,\n    navigationType: action,\n    navigator: staticNavigator,\n    future: future,\n    static: true\n  });\n}\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate = true,\n  nonce\n}) {\n  !(router && context) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = new Map();\n  let hydrateScript = \"\";\n  if (hydrate !== false) {\n    let data = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    // Use JSON.parse here instead of embedding a raw JS object here to speed\n    // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n    // are properly escaped in the resulting string.  See:\n    //   https://v8.dev/blog/cost-of-javascript-2019#json\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let {\n    state\n  } = dataRouterContext.router;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(UNSAFE_FetchersContext.Provider, {\n    value: fetchersContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_ViewTransitionContext.Provider, {\n    value: {\n      isTransitioning: false\n    }\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: dataRouterContext.basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: dataRouterContext.navigator,\n    static: dataRouterContext.static,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  })))))), hydrateScript ? /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: hydrateScript\n    }\n  }) : null);\n}\nfunction DataRoutes({\n  routes,\n  future,\n  state\n}) {\n  return UNSAFE_useRoutesImpl(routes, undefined, state, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in react-router-dom/index.tsx :)\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      // Do not serialize stack traces from SSR for security reasons\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...(val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n    },\n    replace(to) {\n      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n    },\n    go(delta) {\n      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n    },\n    back() {\n      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n    },\n    forward() {\n      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n    }\n  };\n}\nfunction createStaticHandler(routes, opts) {\n  return createStaticHandler$1(routes, {\n    ...opts,\n    mapRouteProperties: UNSAFE_mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = UNSAFE_convertRoutesToDataRoutes(routes, UNSAFE_mapRouteProperties, undefined, manifest);\n\n  // Because our context matches may be from a framework-agnostic set of\n  // routes passed to createStaticHandler(), we update them here with our\n  // newly created/enhanced data routes\n  let matches = context.matches.map(match => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: opts.future?.v7_partialHydration === true,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: opts.future?.v7_relativeSplatPath === true,\n        unstable_skipActionErrorRevalidation: false\n      };\n    },\n    get state() {\n      return {\n        historyAction: Action.Pop,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: new Map(),\n        blockers: new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return undefined;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    patchRoutes() {\n      throw msg(\"patchRoutes\");\n    },\n    _internalFetchControllers: new Map(),\n    _internalActiveDeferreds: new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : createPath(to);\n  // Treating this as a full URL will strip any trailing spaces so we need to\n  // pre-encode them since they might be part of a matching splat param from\n  // an ancestor route\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\nexport { StaticRouter, StaticRouterProvider, createStaticHandler, createStaticRouter };","map":{"version":3,"names":["React","Action","UNSAFE_invariant","isRouteErrorResponse","createStaticHandler","createStaticHandler$1","UNSAFE_convertRoutesToDataRoutes","IDLE_NAVIGATION","IDLE_FETCHER","IDLE_BLOCKER","UNSAFE_useRoutesImpl","UNSAFE_mapRouteProperties","parsePath","Router","UNSAFE_DataRouterContext","UNSAFE_DataRouterStateContext","UNSAFE_FetchersContext","UNSAFE_ViewTransitionContext","createPath","StaticRouter","basename","children","location","locationProp","future","action","Pop","pathname","search","hash","state","key","staticNavigator","getStatelessNavigator","createElement","navigationType","navigator","static","StaticRouterProvider","context","router","hydrate","nonce","process","env","NODE_ENV","dataRouterContext","staticContext","fetchersContext","Map","hydrateScript","data","loaderData","actionData","errors","serializeErrors","json","htmlEscape","JSON","stringify","Fragment","Provider","value","isTransitioning","historyAction","v7_relativeSplatPath","DataRoutes","routes","suppressHydrationWarning","dangerouslySetInnerHTML","__html","undefined","entries","Object","serialized","val","__type","Error","message","name","__subType","createHref","encodeLocation","push","to","replace","go","delta","back","forward","opts","mapRouteProperties","createStaticRouter","manifest","dataRoutes","matches","map","match","route","id","msg","method","v7_fetcherPersist","v7_normalizeFormMethod","v7_partialHydration","v7_prependBasename","unstable_skipActionErrorRevalidation","initialized","navigation","restoreScrollPosition","preventScrollReset","revalidation","fetchers","blockers","window","initialize","subscribe","enableScrollRestoration","navigate","fetch","revalidate","getFetcher","deleteFetcher","dispose","getBlocker","deleteBlocker","patchRoutes","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","href","encoded","ABSOLUTE_URL_REGEX","test","URL","ESCAPE_LOOKUP","ESCAPE_REGEX","str"],"sources":["C:/Users/saiku/OneDrive/Desktop/odin/Bookstore/online_bookstore/node_modules/react-router-dom/server.mjs"],"sourcesContent":["import * as React from 'react';\nimport { Action, UNSAFE_invariant, isRouteErrorResponse, createStaticHandler as createStaticHandler$1, UNSAFE_convertRoutesToDataRoutes, IDLE_NAVIGATION, IDLE_FETCHER, IDLE_BLOCKER } from '@remix-run/router';\nimport { UNSAFE_useRoutesImpl, UNSAFE_mapRouteProperties } from 'react-router';\nimport { parsePath, Router, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_FetchersContext, UNSAFE_ViewTransitionContext, createPath } from 'react-router-dom';\n\n/**\n * A `<Router>` that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\",\n  future\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = Action.Pop;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state != null ? locationProp.state : null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: location,\n    navigationType: action,\n    navigator: staticNavigator,\n    future: future,\n    static: true\n  });\n}\n/**\n * A Data Router that may not navigate to any other location. This is useful\n * on the server where there is no stateful UI.\n */\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate = true,\n  nonce\n}) {\n  !(router && context) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You must provide `router` and `context` to <StaticRouterProvider>\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = new Map();\n  let hydrateScript = \"\";\n  if (hydrate !== false) {\n    let data = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    // Use JSON.parse here instead of embedding a raw JS object here to speed\n    // up parsing on the client.  Dual-stringify is needed to ensure all quotes\n    // are properly escaped in the resulting string.  See:\n    //   https://v8.dev/blog/cost-of-javascript-2019#json\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let {\n    state\n  } = dataRouterContext.router;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(UNSAFE_FetchersContext.Provider, {\n    value: fetchersContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_ViewTransitionContext.Provider, {\n    value: {\n      isTransitioning: false\n    }\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: dataRouterContext.basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: dataRouterContext.navigator,\n    static: dataRouterContext.static,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  })))))), hydrateScript ? /*#__PURE__*/React.createElement(\"script\", {\n    suppressHydrationWarning: true,\n    nonce: nonce,\n    dangerouslySetInnerHTML: {\n      __html: hydrateScript\n    }\n  }) : null);\n}\nfunction DataRoutes({\n  routes,\n  future,\n  state\n}) {\n  return UNSAFE_useRoutesImpl(routes, undefined, state, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in react-router-dom/index.tsx :)\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      // Do not serialize stack traces from SSR for security reasons\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...(val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n    },\n    replace(to) {\n      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere ` + `in your app.`);\n    },\n    go(delta) {\n      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\\`navigate(${delta})\\` somewhere in your app.`);\n    },\n    back() {\n      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);\n    },\n    forward() {\n      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);\n    }\n  };\n}\nfunction createStaticHandler(routes, opts) {\n  return createStaticHandler$1(routes, {\n    ...opts,\n    mapRouteProperties: UNSAFE_mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = UNSAFE_convertRoutesToDataRoutes(routes, UNSAFE_mapRouteProperties, undefined, manifest);\n\n  // Because our context matches may be from a framework-agnostic set of\n  // routes passed to createStaticHandler(), we update them here with our\n  // newly created/enhanced data routes\n  let matches = context.matches.map(match => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: opts.future?.v7_partialHydration === true,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: opts.future?.v7_relativeSplatPath === true,\n        unstable_skipActionErrorRevalidation: false\n      };\n    },\n    get state() {\n      return {\n        historyAction: Action.Pop,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: new Map(),\n        blockers: new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return undefined;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    patchRoutes() {\n      throw msg(\"patchRoutes\");\n    },\n    _internalFetchControllers: new Map(),\n    _internalActiveDeferreds: new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : createPath(to);\n  // Treating this as a full URL will strip any trailing spaces so we need to\n  // pre-encode them since they might be part of a matching splat param from\n  // an ancestor route\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n\nexport { StaticRouter, StaticRouterProvider, createStaticHandler, createStaticRouter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}